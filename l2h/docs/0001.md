# Complete Full-Stack Blog System Setup
**Document ID:** 0001  
**Created:** October 4, 2025  
**Version:** 2.0.0  
**Tech Stack:** React 18.3.1 + TypeScript + Vite + Node.js + MongoDB

---

## Table of Contents
1. [Overview](#overview)
2. [Tech Stack](#tech-stack)
3. [Reference System Analysis](#reference-system-analysis)
4. [Database Setup (MongoDB)](#database-setup-mongodb)
5. [Backend Setup (Node.js + Express)](#backend-setup-nodejs--express)
6. [Frontend Setup (React + TypeScript)](#frontend-setup-react--typescript)
7. [Authentication & Authorization](#authentication--authorization)
8. [File Upload & Storage](#file-upload--storage)
9. [Email Service (OTP)](#email-service-otp)
10. [Complete API Documentation](#complete-api-documentation)
11. [Testing](#testing)
12. [Deployment Guide](#deployment-guide)

---

## Overview

This document provides a **complete, standalone full-stack blogging application** setup guide. This is NOT an integration with the existing Laravel backend - it's a brand new, independent application built from scratch.

**The existing Laravel codebase is used ONLY as a REFERENCE** to understand what features and functionality to implement. We will build our own backend using Node.js + Express + MongoDB.

### Key Features
- ✅ Blog post management (CRUD operations)
- ✅ Category-based organization
- ✅ Author profiles with bio
- ✅ Comment system with OTP verification
- ✅ Search functionality
- ✅ Tag-based filtering
- ✅ Video blog support (embedded & file upload)
- ✅ Related posts recommendations
- ✅ Newsletter subscription
- ✅ Social media sharing
- ✅ SEO-friendly slugs
- ✅ Responsive design
- ✅ JWT authentication
- ✅ Role-based access control (Admin/User/Author)
- ✅ File upload to AWS S3 or local storage
- ✅ Email notifications with OTP

---

## Tech Stack

### Backend
- **Runtime:** Node.js 18+ with TypeScript
- **Framework:** Express.js
- **Database:** MongoDB 6+ with Mongoose ODM
- **Authentication:** JWT (jsonwebtoken) + bcrypt
- **File Upload:** Multer + AWS S3 SDK (optional)
- **Email:** Nodemailer
- **Validation:** Zod
- **Security:** Helmet, CORS, express-rate-limit

### Frontend
- **Framework:** React 18.3.1
- **Language:** TypeScript
- **Build Tool:** Vite
- **Styling:** Tailwind CSS + shadcn/ui
- **State Management:** React Query (TanStack Query)
- **Forms:** React Hook Form + Zod
- **Router:** React Router v6
- **Rich Text:** TipTap
- **HTTP Client:** Axios

### DevOps & Tools
- **Containerization:** Docker + Docker Compose
- **Version Control:** Git
- **Package Manager:** npm/yarn
- **Environment:** dotenv
- **Hosting Options:** 
  - Frontend: Vercel/Netlify
  - Backend: Railway/Render/AWS EC2/DigitalOcean
  - Database: MongoDB Atlas (cloud) or self-hosted

---

## Reference System Analysis

### Laravel Backend (Reference Only)

### Backend Structure (Laravel/PHP)

#### Models

**1. Blog Model** (`project/app/Models/Blog.php`)
```php
protected $fillable = [
    'catgeory_id',      // Category ID (foreign key)
    'author_id',        // Author ID (foreign key)
    'coverimage',       // Cover image URL/path
    'videotype',        // 'file' or 'embed'
    'title',            // Blog post title
    'published_date',   // Publication date
    'description',      // Full HTML content
    'tags',             // Comma-separated tags
    'related_blogs_id', // JSON array of related blog IDs
    'status',           // 0=draft, 1=published
    'isVideo',          // 'yes' or 'no'
    'video',            // Video file path or embed URL
    'slug',             // SEO-friendly URL slug
    'position',         // Display order
];

// Relationships
public function authors() {
    return $this->belongsTo(Author::class, 'author_id');
}
```

**2. BlogCategory Model** (`project/app/Models/BlogCategory.php`)
```php
protected $table = 'blog_categories';
protected $fillable = [
    'name',      // Category name
    'slug',      // URL-friendly slug
    'status',    // 0=inactive, 1=active
    'position',  // Display order
];
```

**3. Author Model** (`project/app/Models/Author.php`)
```php
protected $fillable = [
    'name',         // Author name
    'email',        // Author email
    'bio',          // Author biography
    'image',        // Profile image path
    'facebook',     // Social media links
    'twitter',
    'linkedin',
    'instagram',
    'yotube',       // Note: typo in original DB
];
```

**4. BlogComment Model** (`project/app/Models/BlogComment.php`)
```php
protected $fillable = [
    'name',         // Commenter name
    'email',        // Commenter email
    'mobile',       // Phone number
    'hearabout',    // How they heard about the blog
    'comment',      // Comment text
    'country_code', // Country code for phone
    'state_id',     // State/province ID
    'city_id',      // City ID
];
```

The Laravel backend helps us understand the required features and data structure. We'll implement similar functionality using modern Node.js + MongoDB stack.

---

## Database Setup (MongoDB)

### Installation

```bash
# Install MongoDB (Ubuntu/Debian)
sudo apt update
sudo apt install -y mongodb-org

# Or using Docker
docker run --name blog-mongodb \
  -e MONGO_INITDB_ROOT_USERNAME=admin \
  -e MONGO_INITDB_ROOT_PASSWORD=your_password \
  -e MONGO_INITDB_DATABASE=blog_db \
  -p 27017:27017 \
  -d mongo:6

# Or use MongoDB Atlas (Cloud)
# Sign up at https://www.mongodb.com/cloud/atlas
```

### Mongoose Schemas

Create `backend/src/models/` directory with the following schemas:

#### User Model (for Authors & Authentication)

`backend/src/models/User.ts`:

```typescript
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
  email: string;
  password: string;
  name: string;
  role: 'user' | 'author' | 'admin';
  bio?: string;
  image?: string;
  facebook?: string;
  twitter?: string;
  linkedin?: string;
  instagram?: string;
  youtube?: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const userSchema = new Schema<IUser>(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      index: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
    },
    name: {
      type: String,
      required: true,
      trim: true,
    },
    role: {
      type: String,
      enum: ['user', 'author', 'admin'],
      default: 'user',
    },
    bio: {
      type: String,
      maxlength: 500,
    },
    image: String,
    facebook: String,
    twitter: String,
    linkedin: String,
    instagram: String,
    youtube: String,
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

// Compare password method
userSchema.methods.comparePassword = async function (
  candidatePassword: string
): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

export default mongoose.model<IUser>('User', userSchema);
```

#### BlogCategory Model

`backend/src/models/BlogCategory.ts`:

```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IBlogCategory extends Document {
  name: string;
  slug: string;
  status: 'active' | 'inactive';
  position: number;
  createdAt: Date;
  updatedAt: Date;
}

const blogCategorySchema = new Schema<IBlogCategory>(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    slug: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      index: true,
    },
    status: {
      type: String,
      enum: ['active', 'inactive'],
      default: 'active',
      index: true,
    },
    position: {
      type: Number,
      default: 0,
    },
  },
  {
    timestamps: true,
  }
);

export default mongoose.model<IBlogCategory>('BlogCategory', blogCategorySchema);
```

#### Blog Model

`backend/src/models/Blog.ts`:

```typescript
import mongoose, { Schema, Document, Types } from 'mongoose';

export interface IBlog extends Document {
  title: string;
  slug: string;
  description: string;
  coverImage: string;
  excerpt?: string;
  tags: string[];
  isVideo: boolean;
  videoType?: 'file' | 'embed';
  videoUrl?: string;
  status: 'draft' | 'published' | 'archived';
  publishedAt?: Date;
  viewCount: number;
  position: number;
  metaTitle?: string;
  metaDescription?: string;
  categoryId: Types.ObjectId;
  authorId: Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const blogSchema = new Schema<IBlog>(
  {
    title: {
      type: String,
      required: true,
      trim: true,
    },
    slug: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      index: true,
    },
    description: {
      type: String,
      required: true,
    },
    coverImage: {
      type: String,
      required: true,
    },
    excerpt: {
      type: String,
      maxlength: 300,
    },
    tags: {
      type: [String],
      default: [],
      index: true,
    },
    isVideo: {
      type: Boolean,
      default: false,
    },
    videoType: {
      type: String,
      enum: ['file', 'embed'],
    },
    videoUrl: String,
    status: {
      type: String,
      enum: ['draft', 'published', 'archived'],
      default: 'draft',
      index: true,
    },
    publishedAt: {
      type: Date,
      index: true,
    },
    viewCount: {
      type: Number,
      default: 0,
    },
    position: {
      type: Number,
      default: 0,
    },
    metaTitle: String,
    metaDescription: String,
    categoryId: {
      type: Schema.Types.ObjectId,
      ref: 'BlogCategory',
      required: true,
      index: true,
    },
    authorId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
  },
  {
    timestamps: true,
  }
);

// Text search index
blogSchema.index({ title: 'text', description: 'text', tags: 'text' });

export default mongoose.model<IBlog>('Blog', blogSchema);
```

#### BlogComment Model

`backend/src/models/BlogComment.ts`:

```typescript
import mongoose, { Schema, Document, Types } from 'mongoose';

export interface IBlogComment extends Document {
  name: string;
  email: string;
  mobile?: string;
  countryCode?: string;
  comment: string;
  hearAbout?: string;
  status: 'pending' | 'approved' | 'rejected';
  blogId: Types.ObjectId;
  userId?: Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const blogCommentSchema = new Schema<IBlogComment>(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      lowercase: true,
      trim: true,
    },
    mobile: String,
    countryCode: String,
    comment: {
      type: String,
      required: true,
    },
    hearAbout: String,
    status: {
      type: String,
      enum: ['pending', 'approved', 'rejected'],
      default: 'pending',
      index: true,
    },
    blogId: {
      type: Schema.Types.ObjectId,
      ref: 'Blog',
      required: true,
      index: true,
    },
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
  },
  {
    timestamps: true,
  }
);

export default mongoose.model<IBlogComment>('BlogComment', blogCommentSchema);
```

#### OTP Model

`backend/src/models/OTP.ts`:

```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IOTP extends Document {
  email: string;
  otp: string;
  purpose: 'comment' | 'register' | 'reset-password';
  expiresAt: Date;
  used: boolean;
  createdAt: Date;
}

const otpSchema = new Schema<IOTP>(
  {
    email: {
      type: String,
      required: true,
      lowercase: true,
      index: true,
    },
    otp: {
      type: String,
      required: true,
      index: true,
    },
    purpose: {
      type: String,
      enum: ['comment', 'register', 'reset-password'],
      required: true,
    },
    expiresAt: {
      type: Date,
      required: true,
      index: true,
    },
    used: {
      type: Boolean,
      default: false,
    },
  },
  {
    timestamps: true,
  }
);

// Auto-delete expired OTPs after 1 hour
otpSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 3600 });

export default mongoose.model<IOTP>('OTP', otpSchema);
```

#### Newsletter Model

`backend/src/models/Newsletter.ts`:

```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface INewsletter extends Document {
  email: string;
  name?: string;
  isActive: boolean;
  subscribedAt: Date;
  unsubscribedAt?: Date;
}

const newsletterSchema = new Schema<INewsletter>(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      index: true,
    },
    name: String,
    isActive: {
      type: Boolean,
      default: true,
    },
    subscribedAt: {
      type: Date,
      default: Date.now,
    },
    unsubscribedAt: Date,
  },
  {
    timestamps: true,
  }
);

export default mongoose.model<INewsletter>('Newsletter', newsletterSchema);
```

---

## Backend Setup (Node.js + Express)

### Project Structure

```
backend/
├── src/
│   ├── config/
│   │   ├── database.ts          # MongoDB connection
│   │   ├── email.ts              # Nodemailer config
│   │   └── s3.ts                 # AWS S3 config (optional)
│   ├── models/
│   │   ├── User.ts
│   │   ├── Blog.ts
│   │   ├── BlogCategory.ts
│   │   ├── BlogComment.ts
│   │   ├── OTP.ts
│   │   └── Newsletter.ts
│   ├── controllers/
│   │   ├── authController.ts
│   │   ├── blogController.ts
│   │   ├── categoryController.ts
│   │   ├── commentController.ts
│   │   └── newsletterController.ts
│   ├── middlewares/
│   │   ├── auth.ts               # JWT authentication
│   │   ├── roleCheck.ts          # Role-based access
│   │   ├── upload.ts             # File upload
│   │   └── errorHandler.ts       # Error handling
│   ├── routes/
│   │   ├── auth.ts
│   │   ├── blogs.ts
│   │   ├── categories.ts
│   │   ├── comments.ts
│   │   └── newsletter.ts
│   ├── utils/
│   │   ├── emailService.ts       # Email sending
│   │   ├── generateOTP.ts        # OTP generation
│   │   ├── slugify.ts            # Slug generation
│   │   └── validation.ts         # Zod schemas
│   ├── types/
│   │   └── express.d.ts          # Type declarations
│   ├── app.ts                    # Express app setup
│   └── server.ts                 # Server entry point
├── uploads/                      # Local file storage
├── .env
├── .env.example
├── package.json
├── tsconfig.json
└── README.md
```

### Initial Setup

**1. Initialize Backend Project:**

```bash
mkdir backend
cd backend
npm init -y

# Install dependencies
npm install express mongoose dotenv cors helmet express-rate-limit
npm install jsonwebtoken bcryptjs multer nodemailer
npm install zod express-validator

# Install dev dependencies
npm install -D typescript @types/node @types/express @types/cors
npm install -D @types/jsonwebtoken @types/bcryptjs @types/multer
npm install -D @types/nodemailer ts-node-dev nodemon

# Optional: AWS S3
npm install @aws-sdk/client-s3 multer-s3
```

**2. TypeScript Configuration (`tsconfig.json`):**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "types": ["node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**3. Package.json Scripts:**

```json
{
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "test": "jest"
  }
}
```

### Configuration Files

**Database Connection (`src/config/database.ts`):**

```typescript
import mongoose from 'mongoose';

export const connectDatabase = async (): Promise<void> => {
  try {
    const mongoURI = process.env.MONGODB_URI || 'mongodb://localhost:27017/blog_db';
    
    await mongoose.connect(mongoURI);
    
    console.log('✅ MongoDB connected successfully');
    
    mongoose.connection.on('error', (err) => {
      console.error('MongoDB connection error:', err);
    });
    
    mongoose.connection.on('disconnected', () => {
      console.log('MongoDB disconnected');
    });
  } catch (error) {
    console.error('Failed to connect to MongoDB:', error);
    process.exit(1);
  }
};
```

**Email Configuration (`src/config/email.ts`):**

```typescript
import nodemailer from 'nodemailer';

export const emailTransporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

export const sendEmail = async (
  to: string,
  subject: string,
  html: string
): Promise<void> => {
  try {
    await emailTransporter.sendMail({
      from: process.env.SMTP_FROM || 'noreply@yourblog.com',
      to,
      subject,
      html,
    });
    console.log(`Email sent to ${to}`);
  } catch (error) {
    console.error('Email sending failed:', error);
    throw error;
  }
};
```

### Middleware

**Authentication Middleware (`src/middlewares/auth.ts`):**

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import User, { IUser } from '../models/User';

export interface AuthRequest extends Request {
  user?: IUser;
}

export const authenticate = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      res.status(401).json({ message: 'Authentication required' });
      return;
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string };
    const user = await User.findById(decoded.userId);
    
    if (!user || !user.isActive) {
      res.status(401).json({ message: 'Invalid authentication' });
      return;
    }
    
    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ message: 'Invalid authentication' });
  }
};

export const isAuthor = (req: AuthRequest, res: Response, next: NextFunction): void => {
  if (req.user && (req.user.role === 'author' || req.user.role === 'admin')) {
    next();
  } else {
    res.status(403).json({ message: 'Author access required' });
  }
};

export const isAdmin = (req: AuthRequest, res: Response, next: NextFunction): void => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ message: 'Admin access required' });
  }
};
```

**File Upload Middleware (`src/middlewares/upload.ts`):**

```typescript
import multer from 'multer';
import path from 'path';

// Local storage configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  },
});

const fileFilter = (req: any, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  // Accept images only
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Only image files are allowed!'));
  }
};

export const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
  },
});
```

### Controllers

**Auth Controller (`src/controllers/authController.ts`):**

```typescript
import { Request, Response } from 'express';
import jwt from 'jsonwebtoken';
import User from '../models/User';
import { AuthRequest } from '../middlewares/auth';

export const register = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email, password, name } = req.body;
    
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      res.status(400).json({ message: 'User already exists' });
      return;
    }
    
    const user = new User({
      email,
      password,
      name,
      role: 'user',
    });
    
    await user.save();
    
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET!, {
      expiresIn: '7d',
    });
    
    res.status(201).json({
      message: 'User registered successfully',
      token,
      user: {
        id: user._id,
        email: user.email,
        name: user.name,
        role: user.role,
      },
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

export const login = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email, password } = req.body;
    
    const user = await User.findOne({ email });
    if (!user) {
      res.status(401).json({ message: 'Invalid credentials' });
      return;
    }
    
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      res.status(401).json({ message: 'Invalid credentials' });
      return;
    }
    
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET!, {
      expiresIn: '7d',
    });
    
    res.json({
      message: 'Login successful',
      token,
      user: {
        id: user._id,
        email: user.email,
        name: user.name,
        role: user.role,
      },
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

export const getProfile = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    res.json({
      user: {
        id: req.user!._id,
        email: req.user!.email,
        name: req.user!.name,
        role: req.user!.role,
        bio: req.user!.bio,
        image: req.user!.image,
      },
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};
```

**Blog Controller (`src/controllers/blogController.ts`):**

```typescript
import { Request, Response } from 'express';
import Blog from '../models/Blog';
import BlogCategory from '../models/BlogCategory';
import { AuthRequest } from '../middlewares/auth';

// Get all published blogs (public)
export const getBlogs = async (req: Request, res: Response): Promise<void> => {
  try {
    const {
      category,
      tag,
      search,
      page = 1,
      limit = 10,
      sortBy = 'latest',
    } = req.query;
    
    const query: any = { status: 'published' };
    
    // Category filter
    if (category) {
      const cat = await BlogCategory.findOne({ slug: category as string });
      if (cat) {
        query.categoryId = cat._id;
      }
    }
    
    // Tag filter
    if (tag) {
      query.tags = tag;
    }
    
    // Search filter
    if (search) {
      query.$text = { $search: search as string };
    }
    
    // Sorting
    let sort: any = { publishedAt: -1 }; // latest by default
    if (sortBy === 'oldest') {
      sort = { publishedAt: 1 };
    } else if (sortBy === 'popular') {
      sort = { viewCount: -1 };
    }
    
    const skip = (Number(page) - 1) * Number(limit);
    
    const blogs = await Blog.find(query)
      .populate('authorId', 'name email image bio')
      .populate('categoryId', 'name slug')
      .sort(sort)
      .skip(skip)
      .limit(Number(limit));
    
    const total = await Blog.countDocuments(query);
    
    res.json({
      status: true,
      data: blogs,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        pages: Math.ceil(total / Number(limit)),
      },
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

// Get single blog by slug (public)
export const getBlogBySlug = async (req: Request, res: Response): Promise<void> => {
  try {
    const { slug } = req.params;
    
    const blog = await Blog.findOne({ slug, status: 'published' })
      .populate('authorId', 'name email image bio facebook twitter linkedin instagram youtube')
      .populate('categoryId', 'name slug');
    
    if (!blog) {
      res.status(404).json({ message: 'Blog not found' });
      return;
    }
    
    // Increment view count
    blog.viewCount += 1;
    await blog.save();
    
    res.json({
      status: true,
      data: blog,
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

// Create blog (author/admin only)
export const createBlog = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const blogData = {
      ...req.body,
      authorId: req.user!._id,
    };
    
    // Handle file upload if present
    if (req.file) {
      blogData.coverImage = `/uploads/${req.file.filename}`;
    }
    
    const blog = new Blog(blogData);
    await blog.save();
    
    res.status(201).json({
      status: true,
      message: 'Blog created successfully',
      data: blog,
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

// Update blog (author/admin only)
export const updateBlog = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const blog = await Blog.findById(id);
    
    if (!blog) {
      res.status(404).json({ message: 'Blog not found' });
      return;
    }
    
    // Check ownership (author can only edit their own, admin can edit any)
    if (req.user!.role !== 'admin' && blog.authorId.toString() !== req.user!._id.toString()) {
      res.status(403).json({ message: 'Not authorized to edit this blog' });
      return;
    }
    
    Object.assign(blog, req.body);
    
    if (req.file) {
      blog.coverImage = `/uploads/${req.file.filename}`;
    }
    
    await blog.save();
    
    res.json({
      status: true,
      message: 'Blog updated successfully',
      data: blog,
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

// Delete blog (admin only)
export const deleteBlog = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const blog = await Blog.findByIdAndDelete(id);
    
    if (!blog) {
      res.status(404).json({ message: 'Blog not found' });
      return;
    }
    
    res.json({
      status: true,
      message: 'Blog deleted successfully',
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

// Get related posts
export const getRelatedPosts = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const limit = parseInt(req.query.limit as string) || 3;
    
    const blog = await Blog.findById(id);
    if (!blog) {
      res.status(404).json({ message: 'Blog not found' });
      return;
    }
    
    // Find related posts by category and tags
    const relatedPosts = await Blog.find({
      _id: { $ne: id },
      status: 'published',
      $or: [
        { categoryId: blog.categoryId },
        { tags: { $in: blog.tags } },
      ],
    })
      .populate('authorId', 'name email image')
      .populate('categoryId', 'name slug')
      .limit(limit)
      .sort({ publishedAt: -1 });
    
    res.json({
      status: true,
      data: relatedPosts,
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};
```

### Routes

**Blog Routes (`src/routes/blogs.ts`):**

```typescript
import express from 'express';
import * as blogController from '../controllers/blogController';
import { authenticate, isAuthor, isAdmin } from '../middlewares/auth';
import { upload } from '../middlewares/upload';

const router = express.Router();

// Public routes
router.get('/', blogController.getBlogs);
router.get('/:slug', blogController.getBlogBySlug);
router.get('/:id/related', blogController.getRelatedPosts);

// Protected routes (author/admin)
router.post(
  '/',
  authenticate,
  isAuthor,
  upload.single('coverImage'),
  blogController.createBlog
);

router.put(
  '/:id',
  authenticate,
  isAuthor,
  upload.single('coverImage'),
  blogController.updateBlog
);

// Admin only
router.delete('/:id', authenticate, isAdmin, blogController.deleteBlog);

export default router;
```

### Express App Setup (`src/app.ts`):**

```typescript
import express, { Application } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import path from 'path';

// Import routes
import authRoutes from './routes/auth';
import blogRoutes from './routes/blogs';
import categoryRoutes from './routes/categories';
import commentRoutes from './routes/comments';
import newsletterRoutes from './routes/newsletter';

const app: Application = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
});
app.use('/api/', limiter);

// Static files
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/blogs', blogRoutes);
app.use('/api/categories', categoryRoutes);
app.use('/api/comments', commentRoutes);
app.use('/api/newsletter', newsletterRoutes);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// Error handling
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error(err.stack);
  res.status(err.status || 500).json({
    message: err.message || 'Internal Server Error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
  });
});

export default app;
```

**Server Entry Point (`src/server.ts`):**

```typescript
import dotenv from 'dotenv';
dotenv.config();

import app from './app';
import { connectDatabase } from './config/database';

const PORT = process.env.PORT || 5000;

const startServer = async () => {
  try {
    // Connect to database
    await connectDatabase();
    
    // Start server
    app.listen(PORT, () => {
      console.log(`🚀 Server running on port ${PORT}`);
      console.log(`📍 Environment: ${process.env.NODE_ENV || 'development'}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();
```

### Environment Variables (`.env.example`):

```env
# Server
NODE_ENV=development
PORT=5000

# Database
MONGODB_URI=mongodb://localhost:27017/blog_db

# JWT
JWT_SECRET=your_super_secret_jwt_key_change_this_in_production

# Email (SMTP)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_app_password
SMTP_FROM=noreply@yourblog.com

# AWS S3 (Optional)
AWS_ACCESS_KEY_ID=your_access_key
AWS_SECRET_ACCESS_KEY=your_secret_key
AWS_REGION=us-east-1
AWS_BUCKET_NAME=your_bucket_name

# Frontend URL (for CORS)
FRONTEND_URL=http://localhost:3000
```

### Reference: Existing Laravel Routes (For Feature Parity)

**Public Routes** (`project/routes/web.php`)
```php
// Blog listing (with optional category filter)
Route::any('/blog/{catslug?}', [FrontendController::class, 'blog'])
    ->name('blog');

// Blog detail page
Route::get('/blog-detail/{category?}/{subcategory?}/{childcategory?}', 
    [FrontendController::class, 'blogcatlog'])
    ->name('Frontweb.blogdeatils');

// Add blog comment
Route::any('/blog-comments', [FrontendController::class, 'addblogcomment'])
    ->name('blog-comments');

// Validate OTP for comment submission
Route::post('/validate-otp-blog', [FrontendController::class, 'validateOtpAndSubmitblog'])
    ->name('validate.otp.blog');

// Blog search
Route::post('/blog-search', [FrontendController::class, 'blogsearch'])
    ->name('webfront.blogsearch');

// Thank you page
Route::get('/thank-you-for-blog', [SocialAuthFacebookController::class, 'thanksublog'])
    ->name('thank-you-for-blog');
```

**API Routes** (`project/routes/api.php`)
```php
// Get all blogs with authors
Route::get('/blogs', [MasterController::class, 'blogs']);
```

### Controller Methods

**FrontendController Methods** (`project/app/Http/Controllers/Front/FrontendController.php`)

```php
// 1. Blog Listing
public function blog(Request $request, $catslug = '')
{
    $queryqb = Blog::query();
    $queryqb->where('status', 1);
    
    // Category filter
    if ($catslug) {
        $cat = BlogCategory::where('slug', $catslug)->first();
        if ($cat) {
            $queryqb->where('catgeory_id', $cat->id);
        }
    }
    
    // Tag filter
    if ($request->tag) {
        $queryqb->where('tags', 'LIKE', "%{$request->tag}%");
    }
    
    // Search by title
    if ($request->name) {
        $queryqb->where('title', 'LIKE', "%{$request->name}%");
    }
    
    // Sorting
    $queryqb->orderBy('published_date', 'DESC');
    
    $blog = $queryqb->get();
    $cat = BlogCategory::where('status', 1)
        ->orderBy('position', 'ASC')
        ->get();
        
    return view('website.blog', compact('blog', 'cat'));
}

// 2. Blog Detail
public function blogcatlog(Request $request, $slug = null)
{
    $a = Blog::where('slug', $slug)
        ->where('status', 1)
        ->first();
        
    if ($a) {
        $cat = BlogCategory::where('status', 1)
            ->orderBy('position', 'ASC')
            ->get();
        return view('website.blog-details', compact('a', 'cat'));
    } else {
        return abort(404);
    }
}

// 3. Add Comment (with OTP verification)
public function addblogcomment(Request $request)
{
    // Validate input
    $request->validate([
        'name' => 'required',
        'email' => 'required|email',
        'mobile' => 'required',
        'comment' => 'required',
    ]);
    
    // Generate and send OTP
    $otp = rand(100000, 999999);
    // Store OTP in session
    session(['blog_comment_otp' => $otp]);
    
    // Send OTP via email/SMS
    
    return response()->json(['status' => true, 'message' => 'OTP sent']);
}

// 4. Blog Search
public function blogsearch(Request $request)
{
    $queryqb = Blog::query();
    $queryqb->where('status', 1);
    
    if ($request->keyword) {
        $queryqb->where('title', 'LIKE', "%{$request->keyword}%");
    }
    
    $results = $queryqb->get();
    
    return view('search-results', compact('results'));
}
```

**API Controller** (`project/app/Http/Controllers/Api/MasterController.php`)

```php
public function blogs(Request $request)
{
    $qt = Blog::where('status', 1)
        ->with('authors')
        ->orderBy('published_date', 'ASC')
        ->get();
        
    if (!empty($qt)) {
        $response = [
            'status' => true, 
            'msg' => 'Blog List', 
            'data' => $qt, 
            'path' => asset('project/public/blog/')
        ];
        return response($response, 200);
    } else {
        $response = ['status' => false, 'msg' => 'No blogs found.'];
        return response($response, 422);
    }
}
```

---

## Frontend Implementation Guide

### Project Structure

```
src/
├── pages/
│   ├── Blogs.tsx              # Main blog listing page (already exists)
│   ├── BlogDetail.tsx         # Single blog post page
│   ├── BlogsByCategory.tsx    # Category-filtered blogs
│   └── BlogSearch.tsx         # Search results page
├── components/
│   ├── blog/
│   │   ├── BlogCard.tsx       # Blog post card component
│   │   ├── BlogGrid.tsx       # Grid layout for blog cards
│   │   ├── BlogHero.tsx       # Hero section
│   │   ├── FeaturedPost.tsx   # Featured blog post
│   │   ├── BlogSidebar.tsx    # Sidebar with categories/search
│   │   ├── CommentForm.tsx    # Comment submission form
│   │   ├── CommentList.tsx    # Display comments
│   │   ├── RelatedPosts.tsx   # Related blog posts
│   │   ├── AuthorInfo.tsx     # Author bio card
│   │   └── ShareButtons.tsx   # Social media sharing
│   ├── ui/
│   │   ├── button.tsx
│   │   ├── card.tsx
│   │   ├── badge.tsx
│   │   ├── input.tsx
│   │   ├── textarea.tsx
│   │   └── dialog.tsx
│   └── Footer.tsx
├── lib/
│   ├── api.ts                 # API client configuration
│   ├── blogApi.ts             # Blog-specific API calls
│   └── utils.ts               # Utility functions
├── types/
│   └── blog.ts                # TypeScript interfaces
├── hooks/
│   ├── useBlog.ts             # Custom hook for blog data
│   ├── useBlogs.ts            # Custom hook for blog listing
│   └── useComments.ts         # Custom hook for comments
└── index.css                  # Global styles
```

---

## Complete Setup Instructions

### Step 1: Install Dependencies

```bash
# Core dependencies
npm install axios react-query react-router-dom

# UI Components (if using shadcn/ui)
npm install @radix-ui/react-dialog @radix-ui/react-dropdown-menu
npm install @radix-ui/react-tabs @radix-ui/react-toast
npm install class-variance-authority clsx tailwind-merge

# Icons
npm install lucide-react

# Form handling
npm install react-hook-form zod @hookform/resolvers

# Rich text editor (for admin panel)
npm install @tiptap/react @tiptap/starter-kit @tiptap/extension-image

# Date handling
npm install date-fns

# HTML parsing (for blog content)
npm install html-react-parser

# State management (optional, for complex state)
npm install zustand
```

### Step 2: TypeScript Type Definitions

Create `src/types/blog.ts`:

```typescript
// Core Blog Types
export interface Blog {
  id: number;
  catgeory_id: number;
  author_id: number;
  coverimage: string;
  videotype: 'file' | 'embed' | null;
  title: string;
  published_date: string;
  description: string;
  tags: string;
  related_blogs_id: string | null;
  status: 0 | 1;
  isVideo: 'yes' | 'no';
  video: string | null;
  slug: string;
  position: number;
  created_at: string;
  updated_at: string;
  authors?: Author;
  category?: BlogCategory;
}

export interface BlogCategory {
  id: number;
  name: string;
  slug: string;
  status: 0 | 1;
  position: number;
  created_at: string;
  updated_at: string;
  blog_count?: number; // Calculated field
}

export interface Author {
  id: number;
  name: string;
  email: string;
  bio: string;
  image: string;
  facebook: string | null;
  twitter: string | null;
  linkedin: string | null;
  instagram: string | null;
  yotube: string | null;
  created_at: string;
  updated_at: string;
}

export interface BlogComment {
  id: number;
  blog_id: number;
  name: string;
  email: string;
  mobile: string;
  hearabout: string;
  comment: string;
  country_code: string;
  state_id: number;
  city_id: number;
  status: 0 | 1;
  created_at: string;
  updated_at: string;
}

// API Response Types
export interface BlogListResponse {
  status: boolean;
  msg: string;
  data: Blog[];
  path: string;
}

export interface BlogDetailResponse {
  status: boolean;
  msg: string;
  data: Blog;
  path: string;
}

export interface CommentSubmitData {
  blog_id: number;
  name: string;
  email: string;
  mobile: string;
  country_code: string;
  hearabout: string;
  comment: string;
  state_id?: number;
  city_id?: number;
}

export interface OTPVerificationData {
  otp: string;
  comment_data: CommentSubmitData;
}

// Filter/Search Types
export interface BlogFilters {
  category?: string;
  tag?: string;
  search?: string;
  sortBy?: 'latest' | 'oldest' | 'popular';
  page?: number;
  limit?: number;
}
```

### Step 3: API Configuration

Create `src/lib/api.ts`:

```typescript
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';
const API_IMAGE_BASE = import.meta.env.VITE_IMAGE_URL || 'https://your-s3-url.com';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
});

// Request interceptor
apiClient.interceptors.request.use(
  (config) => {
    // Add auth token if available
    const token = localStorage.getItem('auth_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Handle unauthorized access
      localStorage.removeItem('auth_token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export const getImageUrl = (path: string, type: 'blog' | 'author') => {
  if (path.startsWith('http')) {
    return path;
  }
  return `${API_IMAGE_BASE}/${type}/${path}`;
};

export default apiClient;
```

Create `src/lib/blogApi.ts`:

```typescript
import apiClient, { getImageUrl } from './api';
import type {
  Blog,
  BlogListResponse,
  BlogDetailResponse,
  BlogCategory,
  CommentSubmitData,
  OTPVerificationData,
  BlogFilters,
} from '@/types/blog';

export const blogApi = {
  // Get all blogs with filters
  getBlogs: async (filters?: BlogFilters): Promise<Blog[]> => {
    const params = new URLSearchParams();
    
    if (filters?.category) params.append('category', filters.category);
    if (filters?.tag) params.append('tag', filters.tag);
    if (filters?.search) params.append('search', filters.search);
    if (filters?.page) params.append('page', filters.page.toString());
    if (filters?.limit) params.append('limit', filters.limit.toString());
    
    const response = await apiClient.get<BlogListResponse>(
      `/api/blogs?${params.toString()}`
    );
    
    // Transform image URLs
    return response.data.data.map(blog => ({
      ...blog,
      coverimage: getImageUrl(blog.coverimage, 'blog'),
      authors: blog.authors ? {
        ...blog.authors,
        image: getImageUrl(blog.authors.image, 'author'),
      } : undefined,
    }));
  },

  // Get single blog by slug
  getBlogBySlug: async (slug: string): Promise<Blog> => {
    const response = await apiClient.get<BlogDetailResponse>(
      `/api/blog/${slug}`
    );
    
    const blog = response.data.data;
    return {
      ...blog,
      coverimage: getImageUrl(blog.coverimage, 'blog'),
      authors: blog.authors ? {
        ...blog.authors,
        image: getImageUrl(blog.authors.image, 'author'),
      } : undefined,
    };
  },

  // Get blogs by category
  getBlogsByCategory: async (categorySlug: string): Promise<Blog[]> => {
    const response = await apiClient.get<BlogListResponse>(
      `/api/blogs/category/${categorySlug}`
    );
    
    return response.data.data.map(blog => ({
      ...blog,
      coverimage: getImageUrl(blog.coverimage, 'blog'),
    }));
  },

  // Get all categories
  getCategories: async (): Promise<BlogCategory[]> => {
    const response = await apiClient.get<{ data: BlogCategory[] }>(
      '/api/blog-categories'
    );
    return response.data.data;
  },

  // Search blogs
  searchBlogs: async (keyword: string): Promise<Blog[]> => {
    const response = await apiClient.post<BlogListResponse>(
      '/blog-search',
      { keyword }
    );
    return response.data.data;
  },

  // Submit comment
  submitComment: async (data: CommentSubmitData) => {
    const response = await apiClient.post('/blog-comments', data);
    return response.data;
  },

  // Verify OTP and submit comment
  verifyOTPAndSubmit: async (data: OTPVerificationData) => {
    const response = await apiClient.post('/validate-otp-blog', data);
    return response.data;
  },

  // Get related posts
  getRelatedPosts: async (blogId: number, limit: number = 3): Promise<Blog[]> => {
    const response = await apiClient.get<BlogListResponse>(
      `/api/blogs/${blogId}/related?limit=${limit}`
    );
    return response.data.data;
  },
};
```

### Step 4: Custom React Hooks

Create `src/hooks/useBlogs.ts`:

```typescript
import { useQuery } from '@tanstack/react-query';
import { blogApi } from '@/lib/blogApi';
import type { BlogFilters } from '@/types/blog';

export const useBlogs = (filters?: BlogFilters) => {
  return useQuery({
    queryKey: ['blogs', filters],
    queryFn: () => blogApi.getBlogs(filters),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};

export const useBlog = (slug: string) => {
  return useQuery({
    queryKey: ['blog', slug],
    queryFn: () => blogApi.getBlogBySlug(slug),
    enabled: !!slug,
  });
};

export const useCategories = () => {
  return useQuery({
    queryKey: ['blog-categories'],
    queryFn: () => blogApi.getCategories(),
    staleTime: 10 * 60 * 1000, // 10 minutes
  });
};

export const useRelatedPosts = (blogId: number, limit?: number) => {
  return useQuery({
    queryKey: ['related-posts', blogId, limit],
    queryFn: () => blogApi.getRelatedPosts(blogId, limit),
    enabled: !!blogId,
  });
};
```

### Step 5: Core Components

#### BlogCard Component

Create `src/components/blog/BlogCard.tsx`:

```typescript
import { Link } from 'react-router-dom';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Calendar, User, ArrowRight } from 'lucide-react';
import { format } from 'date-fns';
import type { Blog } from '@/types/blog';

interface BlogCardProps {
  blog: Blog;
  featured?: boolean;
}

export const BlogCard = ({ blog, featured = false }: BlogCardProps) => {
  const imageUrl = blog.coverimage;
  const publishedDate = format(new Date(blog.published_date), 'MMM dd, yyyy');
  const tags = blog.tags ? blog.tags.split(',').map(t => t.trim()) : [];

  return (
    <Card className="hover-lift overflow-hidden">
      <Link to={`/blog/${blog.slug}`}>
        <div className={`relative overflow-hidden ${featured ? 'aspect-[4/3]' : 'aspect-video'}`}>
          <img
            src={imageUrl}
            alt={blog.title}
            className="w-full h-full object-cover hover-scale transition-transform"
          />
          {blog.isVideo === 'yes' && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/30">
              <div className="w-16 h-16 rounded-full bg-white/90 flex items-center justify-center">
                <svg className="w-6 h-6 text-primary ml-1" fill="currentColor" viewBox="0 0 20 20">
                  <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" />
                </svg>
              </div>
            </div>
          )}
        </div>
      </Link>

      <CardContent className="p-6">
        {blog.category && (
          <Badge variant="secondary" className="mb-3">
            {blog.category.name}
          </Badge>
        )}

        <Link to={`/blog/${blog.slug}`}>
          <CardTitle className={`${featured ? 'text-2xl' : 'text-xl'} mb-3 hover:text-primary transition-colors line-clamp-2`}>
            {blog.title}
          </CardTitle>
        </Link>

        {featured && (
          <CardDescription className="mb-4 line-clamp-3">
            <div dangerouslySetInnerHTML={{ 
              __html: blog.description.substring(0, 150) + '...' 
            }} />
          </CardDescription>
        )}

        <div className="flex items-center gap-4 text-sm text-muted-foreground mb-4">
          {blog.authors && (
            <div className="flex items-center gap-2">
              <img
                src={blog.authors.image}
                alt={blog.authors.name}
                className="w-6 h-6 rounded-full object-cover"
              />
              <span>{blog.authors.name}</span>
            </div>
          )}
          <div className="flex items-center gap-1">
            <Calendar className="w-4 h-4" />
            <span>{publishedDate}</span>
          </div>
        </div>

        {tags.length > 0 && (
          <div className="flex flex-wrap gap-2 mb-4">
            {tags.slice(0, 3).map((tag, index) => (
              <Badge key={index} variant="outline" className="text-xs">
                {tag}
              </Badge>
            ))}
          </div>
        )}

        <Link to={`/blog/${blog.slug}`}>
          <Button variant="ghost" className="w-full group">
            Read More
            <ArrowRight className="w-4 h-4 ml-2 group-hover:translate-x-1 transition-transform" />
          </Button>
        </Link>
      </CardContent>
    </Card>
  );
};
```

#### BlogDetail Page

Create `src/pages/BlogDetail.tsx`:

```typescript
import { useParams, Link } from 'react-router-dom';
import { useBlog, useRelatedPosts } from '@/hooks/useBlogs';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Calendar, User, Share2, Tag } from 'lucide-react';
import { format } from 'date-fns';
import parse from 'html-react-parser';
import { BlogCard } from '@/components/blog/BlogCard';
import { CommentForm } from '@/components/blog/CommentForm';
import { ShareButtons } from '@/components/blog/ShareButtons';
import { AuthorInfo } from '@/components/blog/AuthorInfo';
import Footer from '@/components/Footer';

export const BlogDetail = () => {
  const { slug } = useParams<{ slug: string }>();
  const { data: blog, isLoading, error } = useBlog(slug!);
  const { data: relatedPosts } = useRelatedPosts(blog?.id || 0, 3);

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
      </div>
    );
  }

  if (error || !blog) {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center">
        <h1 className="text-4xl font-bold mb-4">Blog Not Found</h1>
        <p className="text-muted-foreground mb-8">The blog post you're looking for doesn't exist.</p>
        <Link to="/blog">
          <Button>Back to Blogs</Button>
        </Link>
      </div>
    );
  }

  const publishedDate = format(new Date(blog.published_date), 'MMMM dd, yyyy');
  const tags = blog.tags ? blog.tags.split(',').map(t => t.trim()) : [];

  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-muted/20">
      {/* Hero Section */}
      <section className="py-20 px-4">
        <div className="max-w-4xl mx-auto">
          {/* Category Badge */}
          {blog.category && (
            <Link to={`/blog/category/${blog.category.slug}`}>
              <Badge variant="secondary" className="mb-4">
                {blog.category.name}
              </Badge>
            </Link>
          )}

          {/* Title */}
          <h1 className="text-4xl md:text-5xl font-bold mb-6">{blog.title}</h1>

          {/* Meta Information */}
          <div className="flex flex-wrap items-center gap-6 text-muted-foreground mb-8">
            {blog.authors && (
              <div className="flex items-center gap-2">
                <img
                  src={blog.authors.image}
                  alt={blog.authors.name}
                  className="w-10 h-10 rounded-full object-cover"
                />
                <div>
                  <p className="font-medium text-foreground">{blog.authors.name}</p>
                  <p className="text-sm">{publishedDate}</p>
                </div>
              </div>
            )}
          </div>

          {/* Cover Image or Video */}
          <div className="relative rounded-lg overflow-hidden mb-8">
            {blog.isVideo === 'yes' ? (
              blog.videotype === 'file' ? (
                <video
                  controls
                  poster={blog.coverimage}
                  className="w-full"
                  controlsList="nodownload"
                >
                  <source src={blog.video!} type="video/mp4" />
                  Your browser does not support the video tag.
                </video>
              ) : (
                <div className="aspect-video">
                  <iframe
                    src={blog.video!}
                    className="w-full h-full"
                    allowFullScreen
                    title={blog.title}
                  />
                </div>
              )
            ) : (
              <img
                src={blog.coverimage}
                alt={blog.title}
                className="w-full aspect-[21/9] object-cover"
              />
            )}
          </div>
        </div>
      </section>

      {/* Content Section */}
      <section className="pb-12 px-4">
        <div className="max-w-4xl mx-auto">
          <div className="prose prose-lg max-w-none mb-12">
            {parse(blog.description)}
          </div>

          {/* Tags */}
          {tags.length > 0 && (
            <div className="flex flex-wrap items-center gap-2 mb-8">
              <Tag className="w-5 h-5 text-muted-foreground" />
              {tags.map((tag, index) => (
                <Link key={index} to={`/blog?tag=${encodeURIComponent(tag)}`}>
                  <Badge variant="outline" className="hover:bg-primary hover:text-primary-foreground transition-colors">
                    {tag}
                  </Badge>
                </Link>
              ))}
            </div>
          )}

          {/* Share Buttons */}
          <div className="border-y py-6 mb-12">
            <ShareButtons blog={blog} />
          </div>

          {/* Author Info */}
          {blog.authors && (
            <div className="mb-12">
              <AuthorInfo author={blog.authors} />
            </div>
          )}

          {/* Related Posts */}
          {relatedPosts && relatedPosts.length > 0 && (
            <div className="mb-12">
              <h2 className="text-3xl font-bold mb-8">Related Posts</h2>
              <div className="grid md:grid-cols-3 gap-6">
                {relatedPosts.map((post) => (
                  <BlogCard key={post.id} blog={post} />
                ))}
              </div>
            </div>
          )}

          {/* Comments Section */}
          <div>
            <h2 className="text-3xl font-bold mb-8">Leave a Comment</h2>
            <CommentForm blogId={blog.id} />
          </div>
        </div>
      </section>

      <Footer />
    </div>
  );
};
```

#### CommentForm Component

Create `src/components/blog/CommentForm.tsx`:

```typescript
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { blogApi } from '@/lib/blogApi';
import { toast } from '@/hooks/use-toast';

const commentSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  mobile: z.string().min(10, 'Invalid phone number'),
  country_code: z.string().default('+91'),
  hearabout: z.string().optional(),
  comment: z.string().min(10, 'Comment must be at least 10 characters'),
});

type CommentFormData = z.infer<typeof commentSchema>;

interface CommentFormProps {
  blogId: number;
}

export const CommentForm = ({ blogId }: CommentFormProps) => {
  const [showOTPDialog, setShowOTPDialog] = useState(false);
  const [otp, setOtp] = useState('');
  const [pendingComment, setPendingComment] = useState<CommentFormData | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<CommentFormData>({
    resolver: zodResolver(commentSchema),
  });

  const onSubmit = async (data: CommentFormData) => {
    try {
      setIsSubmitting(true);
      const response = await blogApi.submitComment({
        blog_id: blogId,
        ...data,
      });

      if (response.status) {
        setPendingComment(data);
        setShowOTPDialog(true);
        toast({
          title: 'OTP Sent',
          description: 'Please check your email for the verification code.',
        });
      }
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to submit comment. Please try again.',
        variant: 'destructive',
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const verifyOTP = async () => {
    if (!pendingComment) return;

    try {
      setIsSubmitting(true);
      await blogApi.verifyOTPAndSubmit({
        otp,
        comment_data: {
          blog_id: blogId,
          ...pendingComment,
        },
      });

      toast({
        title: 'Success',
        description: 'Your comment has been submitted successfully!',
      });

      setShowOTPDialog(false);
      setOtp('');
      reset();
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Invalid OTP. Please try again.',
        variant: 'destructive',
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <>
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
        <div className="grid md:grid-cols-2 gap-6">
          <div>
            <Input
              placeholder="Your Name *"
              {...register('name')}
              className={errors.name ? 'border-red-500' : ''}
            />
            {errors.name && (
              <p className="text-sm text-red-500 mt-1">{errors.name.message}</p>
            )}
          </div>

          <div>
            <Input
              type="email"
              placeholder="Your Email *"
              {...register('email')}
              className={errors.email ? 'border-red-500' : ''}
            />
            {errors.email && (
              <p className="text-sm text-red-500 mt-1">{errors.email.message}</p>
            )}
          </div>
        </div>

        <div className="grid md:grid-cols-2 gap-6">
          <div>
            <Input
              placeholder="Phone Number *"
              {...register('mobile')}
              className={errors.mobile ? 'border-red-500' : ''}
            />
            {errors.mobile && (
              <p className="text-sm text-red-500 mt-1">{errors.mobile.message}</p>
            )}
          </div>

          <div>
            <Input
              placeholder="How did you hear about us?"
              {...register('hearabout')}
            />
          </div>
        </div>

        <div>
          <Textarea
            placeholder="Your Comment *"
            rows={5}
            {...register('comment')}
            className={errors.comment ? 'border-red-500' : ''}
          />
          {errors.comment && (
            <p className="text-sm text-red-500 mt-1">{errors.comment.message}</p>
          )}
        </div>

        <Button type="submit" disabled={isSubmitting} className="w-full md:w-auto">
          {isSubmitting ? 'Submitting...' : 'Submit Comment'}
        </Button>
      </form>

      {/* OTP Verification Dialog */}
      <Dialog open={showOTPDialog} onOpenChange={setShowOTPDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Verify OTP</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <p className="text-sm text-muted-foreground">
              Please enter the OTP sent to your email address.
            </p>
            <Input
              placeholder="Enter OTP"
              value={otp}
              onChange={(e) => setOtp(e.target.value)}
              maxLength={6}
            />
            <Button
              onClick={verifyOTP}
              disabled={isSubmitting || otp.length !== 6}
              className="w-full"
            >
              {isSubmitting ? 'Verifying...' : 'Verify & Submit'}
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
};
```

---

## Admin Panel Setup

### Admin Dashboard Structure

```
src/
├── pages/
│   └── admin/
│       ├── AdminLogin.tsx
│       ├── Dashboard.tsx
│       ├── BlogList.tsx
│       ├── BlogCreate.tsx
│       ├── BlogEdit.tsx
│       ├── CategoryList.tsx
│       ├── CategoryCreate.tsx
│       ├── AuthorList.tsx
│       ├── CommentModeration.tsx
│       └── Settings.tsx
├── components/
│   └── admin/
│       ├── AdminLayout.tsx
│       ├── Sidebar.tsx
│       ├── Header.tsx
│       ├── RichTextEditor.tsx
│       ├── ImageUpload.tsx
│       ├── VideoUpload.tsx
│       └── SlugGenerator.tsx
```

### Rich Text Editor Setup

```typescript
// src/components/admin/RichTextEditor.tsx
import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image';
import { Button } from '@/components/ui/button';
import {
  Bold,
  Italic,
  Underline,
  List,
  ListOrdered,
  Quote,
  Code,
  Heading1,
  Heading2,
  ImagePlus,
} from 'lucide-react';

interface RichTextEditorProps {
  content: string;
  onChange: (html: string) => void;
}

export const RichTextEditor = ({ content, onChange }: RichTextEditorProps) => {
  const editor = useEditor({
    extensions: [
      StarterKit,
      Image.configure({
        HTMLAttributes: {
          class: 'max-w-full h-auto',
        },
      }),
    ],
    content,
    onUpdate: ({ editor }) => {
      onChange(editor.getHTML());
    },
  });

  if (!editor) return null;

  const addImage = () => {
    const url = window.prompt('Enter image URL:');
    if (url) {
      editor.chain().focus().setImage({ src: url }).run();
    }
  };

  return (
    <div className="border rounded-lg overflow-hidden">
      {/* Toolbar */}
      <div className="flex flex-wrap gap-1 p-2 border-b bg-muted/50">
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => editor.chain().focus().toggleBold().run()}
          className={editor.isActive('bold') ? 'bg-muted' : ''}
        >
          <Bold className="w-4 h-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => editor.chain().focus().toggleItalic().run()}
          className={editor.isActive('italic') ? 'bg-muted' : ''}
        >
          <Italic className="w-4 h-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
          className={editor.isActive('heading', { level: 1 }) ? 'bg-muted' : ''}
        >
          <Heading1 className="w-4 h-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
          className={editor.isActive('heading', { level: 2 }) ? 'bg-muted' : ''}
        >
          <Heading2 className="w-4 h-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => editor.chain().focus().toggleBulletList().run()}
          className={editor.isActive('bulletList') ? 'bg-muted' : ''}
        >
          <List className="w-4 h-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => editor.chain().focus().toggleOrderedList().run()}
          className={editor.isActive('orderedList') ? 'bg-muted' : ''}
        >
          <ListOrdered className="w-4 h-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => editor.chain().focus().toggleBlockquote().run()}
          className={editor.isActive('blockquote') ? 'bg-muted' : ''}
        >
          <Quote className="w-4 h-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => editor.chain().focus().toggleCodeBlock().run()}
          className={editor.isActive('codeBlock') ? 'bg-muted' : ''}
        >
          <Code className="w-4 h-4" />
        </Button>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={addImage}
        >
          <ImagePlus className="w-4 h-4" />
        </Button>
      </div>

      {/* Editor Content */}
      <EditorContent
        editor={editor}
        className="prose max-w-none p-4 min-h-[300px] focus:outline-none"
      />
    </div>
  );
};
```

### Blog Create/Edit Form

```typescript
// src/pages/admin/BlogCreate.tsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useNavigate } from 'react-router-dom';
import { RichTextEditor } from '@/components/admin/RichTextEditor';
import { ImageUpload } from '@/components/admin/ImageUpload';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select } from '@/components/ui/select';
import { Switch } from '@/components/ui/switch';
import { toast } from '@/hooks/use-toast';
import { blogApi } from '@/lib/blogApi';

interface BlogFormData {
  title: string;
  slug: string;
  catgeory_id: number;
  author_id: number;
  coverimage: File | null;
  description: string;
  tags: string;
  isVideo: 'yes' | 'no';
  videotype: 'file' | 'embed' | null;
  video: string | File | null;
  status: 0 | 1;
  published_date: string;
  position: number;
}

export const BlogCreate = () => {
  const navigate = useNavigate();
  const [description, setDescription] = useState('');
  const [coverImage, setCoverImage] = useState<File | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const { register, handleSubmit, watch, setValue, formState: { errors } } = useForm<BlogFormData>({
    defaultValues: {
      status: 1,
      isVideo: 'no',
      position: 0,
    },
  });

  const isVideo = watch('isVideo');
  const title = watch('title');

  // Auto-generate slug from title
  const generateSlug = (text: string) => {
    return text
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/(^-|-$)/g, '');
  };

  const onSubmit = async (data: BlogFormData) => {
    try {
      setIsSubmitting(true);

      // Create FormData for file upload
      const formData = new FormData();
      Object.entries(data).forEach(([key, value]) => {
        if (value !== null && value !== undefined) {
          formData.append(key, value.toString());
        }
      });

      formData.set('description', description);
      
      if (coverImage) {
        formData.set('coverimage', coverImage);
      }

      await blogApi.createBlog(formData);

      toast({
        title: 'Success',
        description: 'Blog post created successfully!',
      });

      navigate('/admin/blogs');
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to create blog post. Please try again.',
        variant: 'destructive',
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="container mx-auto py-8">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold mb-8">Create New Blog Post</h1>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-8">
          {/* Title */}
          <div>
            <label className="block text-sm font-medium mb-2">
              Title *
            </label>
            <Input
              {...register('title', { required: 'Title is required' })}
              onChange={(e) => {
                register('title').onChange(e);
                setValue('slug', generateSlug(e.target.value));
              }}
              placeholder="Enter blog title"
            />
            {errors.title && (
              <p className="text-sm text-red-500 mt-1">{errors.title.message}</p>
            )}
          </div>

          {/* Slug */}
          <div>
            <label className="block text-sm font-medium mb-2">
              URL Slug *
            </label>
            <Input
              {...register('slug', { required: 'Slug is required' })}
              placeholder="url-friendly-slug"
            />
            {errors.slug && (
              <p className="text-sm text-red-500 mt-1">{errors.slug.message}</p>
            )}
          </div>

          {/* Category & Author */}
          <div className="grid md:grid-cols-2 gap-6">
            <div>
              <label className="block text-sm font-medium mb-2">
                Category *
              </label>
              {/* Add Select component with categories */}
            </div>

            <div>
              <label className="block text-sm font-medium mb-2">
                Author *
              </label>
              {/* Add Select component with authors */}
            </div>
          </div>

          {/* Cover Image */}
          <div>
            <label className="block text-sm font-medium mb-2">
              Cover Image *
            </label>
            <ImageUpload
              value={coverImage}
              onChange={setCoverImage}
            />
          </div>

          {/* Is Video */}
          <div className="flex items-center gap-4">
            <Switch
              checked={isVideo === 'yes'}
              onCheckedChange={(checked) => 
                setValue('isVideo', checked ? 'yes' : 'no')
              }
            />
            <label className="text-sm font-medium">
              This is a video blog post
            </label>
          </div>

          {/* Video Fields (conditional) */}
          {isVideo === 'yes' && (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-2">
                  Video Type
                </label>
                <select {...register('videotype')} className="w-full border rounded-md p-2">
                  <option value="embed">Embed URL (YouTube, Vimeo, etc.)</option>
                  <option value="file">Upload File</option>
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium mb-2">
                  Video URL or File
                </label>
                <Input
                  {...register('video')}
                  placeholder="Enter video URL or upload file"
                />
              </div>
            </div>
          )}

          {/* Rich Text Editor */}
          <div>
            <label className="block text-sm font-medium mb-2">
              Content *
            </label>
            <RichTextEditor
              content={description}
              onChange={setDescription}
            />
          </div>

          {/* Tags */}
          <div>
            <label className="block text-sm font-medium mb-2">
              Tags (comma-separated)
            </label>
            <Input
              {...register('tags')}
              placeholder="career, growth, tips"
            />
          </div>

          {/* Published Date & Status */}
          <div className="grid md:grid-cols-2 gap-6">
            <div>
              <label className="block text-sm font-medium mb-2">
                Published Date
              </label>
              <Input
                type="date"
                {...register('published_date')}
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-2">
                Status
              </label>
              <select {...register('status')} className="w-full border rounded-md p-2">
                <option value="0">Draft</option>
                <option value="1">Published</option>
              </select>
            </div>
          </div>

          {/* Submit Buttons */}
          <div className="flex gap-4">
            <Button
              type="submit"
              disabled={isSubmitting}
              className="flex-1"
            >
              {isSubmitting ? 'Creating...' : 'Create Blog Post'}
            </Button>
            <Button
              type="button"
              variant="outline"
              onClick={() => navigate('/admin/blogs')}
            >
              Cancel
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
};
```

---

## Deployment Guide

### Environment Variables

Create `.env` file:

```env
# API Configuration
VITE_API_URL=https://your-api-domain.com
VITE_IMAGE_URL=https://your-s3-bucket.amazonaws.com

# Optional: Analytics
VITE_GA_TRACKING_ID=UA-XXXXXXXXX-X

# Optional: Social Login
VITE_FACEBOOK_APP_ID=xxxxx
VITE_GOOGLE_CLIENT_ID=xxxxx
```

### Build Configuration

Update `vite.config.ts`:

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: false,
    minify: 'esbuild',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom', 'react-router-dom'],
          ui: ['@radix-ui/react-dialog', '@radix-ui/react-dropdown-menu'],
        },
      },
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
    },
  },
});
```

### Deployment Steps

1. **Build the project:**
   ```bash
   npm run build
   ```

2. **Deploy to Vercel/Netlify:**
   ```bash
   # Vercel
   vercel --prod

   # Netlify
   netlify deploy --prod --dir=dist
   ```

3. **Configure Backend CORS:**
   Update Laravel `config/cors.php`:
   ```php
   'allowed_origins' => [
       'https://your-frontend-domain.com',
   ],
   ```

---

## Summary

This documentation provides a complete blueprint for recreating the existing Laravel/PHP blogging system in React + TypeScript + Vite. The implementation includes:

✅ Full TypeScript type safety  
✅ Modern React hooks and patterns  
✅ Reusable component architecture  
✅ API integration with existing backend  
✅ Rich text editing capabilities  
✅ Image and video support  
✅ Comment system with OTP verification  
✅ SEO-friendly URLs  
✅ Responsive design  
✅ Admin panel for content management  

### Next Steps

1. Set up the React project with Vite
2. Install all dependencies
3. Create the type definitions
4. Implement API client and hooks
5. Build core components
6. Create page layouts
7. Implement admin panel
8. Test thoroughly
9. Deploy to production

For questions or issues, refer to the specific sections above or consult the Laravel backend documentation.

---

**Last Updated:** October 4, 2025  
**Maintained By:** Development Team  
**Version:** 1.0.0

